/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */

import {
  Address,
  Contract,
  ContractState,
  TestContractResult,
  HexString,
  ContractFactory,
  EventSubscribeOptions,
  EventSubscription,
  CallContractParams,
  CallContractResult,
  TestContractParams,
  ContractEvent,
  subscribeContractEvent,
  subscribeContractEvents,
  testMethod,
  callMethod,
  multicallMethods,
  fetchContractState,
  ContractInstance,
  getContractEventsCurrentCount,
  TestContractParamsWithoutMaps,
  TestContractResultWithoutMaps,
} from "@alephium/web3";
import { default as SaleFlatPriceAlphContractJson } from "../launch_sale/SaleFlatPriceAlph.ral.json";
import { getContractByCodeHash } from "./contracts";

// Custom types for the contract
export namespace SaleFlatPriceAlphTypes {
  export type Fields = {
    burnAlphContract: HexString;
    rewardDistributor: HexString;
    saleOwner: Address;
    accountTemplateId: HexString;
    tokenPrice: bigint;
    saleStart: bigint;
    saleEnd: bigint;
    minRaise: bigint;
    maxRaise: bigint;
    saleTokenId: HexString;
    saleTokenTotalAmount: bigint;
    bidTokenId: HexString;
    whitelistSaleStart: bigint;
    whitelistSaleEnd: bigint;
    whitelistBuyerMaxBid: bigint;
    tokensSold: bigint;
    totalRaised: bigint;
    merkleRoot: HexString;
  };

  export type State = ContractState<Fields>;

  export type BuyEvent = ContractEvent<{
    account: Address;
    buyBidAmount: bigint;
    buyTokenAmount: bigint;
  }>;
  export type AccountCreateEvent = ContractEvent<{
    account: Address;
    contractId: HexString;
  }>;
  export type AccountDestroyEvent = ContractEvent<{
    account: Address;
    contractId: HexString;
  }>;
  export type ClaimBuyerEvent = ContractEvent<{
    account: Address;
    saleTokenAmount: bigint;
  }>;
  export type ClaimBuyerRefundEvent = ContractEvent<{
    account: Address;
    bidTokenAmount: bigint;
  }>;
  export type ClaimSellerEvent = ContractEvent<{
    account: Address;
    bidTokenAmount: bigint;
  }>;
  export type ClaimSellerRefundEvent = ContractEvent<{
    account: Address;
    saleTokenAmount: bigint;
  }>;
  export type UpdateRootEvent = ContractEvent<{
    newMerkleRoot: HexString;
    updatedBy: Address;
  }>;

  export interface CallMethodTable {
    calculateSaleTokensReceivedPerBidTokens: {
      params: CallContractParams<{ bidAmount: bigint }>;
      result: CallContractResult<bigint>;
    };
    accountExists: {
      params: CallContractParams<{ account: Address }>;
      result: CallContractResult<boolean>;
    };
    getSubContractId: {
      params: CallContractParams<{ account: Address }>;
      result: CallContractResult<HexString>;
    };
    isSaleLive: {
      params: Omit<CallContractParams<{}>, "args">;
      result: CallContractResult<boolean>;
    };
    isSaleFinished: {
      params: Omit<CallContractParams<{}>, "args">;
      result: CallContractResult<boolean>;
    };
    isSaleSuccess: {
      params: Omit<CallContractParams<{}>, "args">;
      result: CallContractResult<boolean>;
    };
    isWhitelistSaleLive: {
      params: Omit<CallContractParams<{}>, "args">;
      result: CallContractResult<boolean>;
    };
    isWhitelistSale: {
      params: Omit<CallContractParams<{}>, "args">;
      result: CallContractResult<boolean>;
    };
    isCallerSaleOwner: {
      params: CallContractParams<{ caller: Address }>;
      result: CallContractResult<boolean>;
    };
    getSaleOwner: {
      params: Omit<CallContractParams<{}>, "args">;
      result: CallContractResult<Address>;
    };
    getSaleStart: {
      params: Omit<CallContractParams<{}>, "args">;
      result: CallContractResult<bigint>;
    };
    getSaleEnd: {
      params: Omit<CallContractParams<{}>, "args">;
      result: CallContractResult<bigint>;
    };
    getMinRaise: {
      params: Omit<CallContractParams<{}>, "args">;
      result: CallContractResult<bigint>;
    };
    getMaxRaise: {
      params: Omit<CallContractParams<{}>, "args">;
      result: CallContractResult<bigint>;
    };
    getSaleTokenId: {
      params: Omit<CallContractParams<{}>, "args">;
      result: CallContractResult<HexString>;
    };
    getBidTokenId: {
      params: Omit<CallContractParams<{}>, "args">;
      result: CallContractResult<HexString>;
    };
    getWhitelistSaleStart: {
      params: Omit<CallContractParams<{}>, "args">;
      result: CallContractResult<bigint>;
    };
    getWhitelistSaleEnd: {
      params: Omit<CallContractParams<{}>, "args">;
      result: CallContractResult<bigint>;
    };
    getTokensSold: {
      params: Omit<CallContractParams<{}>, "args">;
      result: CallContractResult<bigint>;
    };
    getTotalRaised: {
      params: Omit<CallContractParams<{}>, "args">;
      result: CallContractResult<bigint>;
    };
    getMerkleRoot: {
      params: Omit<CallContractParams<{}>, "args">;
      result: CallContractResult<HexString>;
    };
  }
  export type CallMethodParams<T extends keyof CallMethodTable> =
    CallMethodTable[T]["params"];
  export type CallMethodResult<T extends keyof CallMethodTable> =
    CallMethodTable[T]["result"];
  export type MultiCallParams = Partial<{
    [Name in keyof CallMethodTable]: CallMethodTable[Name]["params"];
  }>;
  export type MultiCallResults<T extends MultiCallParams> = {
    [MaybeName in keyof T]: MaybeName extends keyof CallMethodTable
      ? CallMethodTable[MaybeName]["result"]
      : undefined;
  };
}

class Factory extends ContractFactory<
  SaleFlatPriceAlphInstance,
  SaleFlatPriceAlphTypes.Fields
> {
  getInitialFieldsWithDefaultValues() {
    return this.contract.getInitialFieldsWithDefaultValues() as SaleFlatPriceAlphTypes.Fields;
  }

  eventIndex = {
    Buy: 0,
    AccountCreate: 1,
    AccountDestroy: 2,
    ClaimBuyer: 3,
    ClaimBuyerRefund: 4,
    ClaimSeller: 5,
    ClaimSellerRefund: 6,
    UpdateRoot: 7,
  };
  consts = {
    ErrorCodes: {
      PriceMoreThanMax: BigInt(601),
      PriceLessThanMin: BigInt(602),
      BidMoreThanMax: BigInt(603),
      BidLessThanMin: BigInt(604),
      InvalidClaimAmount: BigInt(605),
      SaleTokenTotalExceeded: BigInt(606),
      SaleOwnerCanNotBid: BigInt(607),
      BuyerNotWhitelisted: BigInt(608),
      SaleTokenMoreThan18Decimal: BigInt(609),
      SaleAmountSmallerThanMin: BigInt(610),
      SaleAmountLargerThanMax: BigInt(611),
    },
    AccountErrorCodes: {
      AccountAlreadyExists: BigInt(12001),
      AccountDoesNotExists: BigInt(12002),
    },
    MerkleProofErrorCodes: {
      InvalidProofSize: BigInt(11001),
      InvalidDataHash: BigInt(11002),
    },
    SaleBaseErrorCodes: {
      SaleNotLive: BigInt(1001),
      SaleNotFinished: BigInt(1002),
      SaleClaimNotAvailable: BigInt(1003),
      SaleRefundNotAvailable: BigInt(1004),
      SaleAlreadyStarted: BigInt(1005),
      SaleUpdateUnauthorized: BigInt(1006),
      SaleIsNotWLSale: BigInt(1007),
    },
  };

  at(address: string): SaleFlatPriceAlphInstance {
    return new SaleFlatPriceAlphInstance(address);
  }

  tests = {
    claimBuyer: async (
      params: TestContractParamsWithoutMaps<
        SaleFlatPriceAlphTypes.Fields,
        { caller: Address; amount: bigint }
      >
    ): Promise<TestContractResultWithoutMaps<null>> => {
      return testMethod(this, "claimBuyer", params);
    },
    claimBuyerRefund: async (
      params: TestContractParamsWithoutMaps<
        SaleFlatPriceAlphTypes.Fields,
        { caller: Address; amount: bigint }
      >
    ): Promise<TestContractResultWithoutMaps<null>> => {
      return testMethod(this, "claimBuyerRefund", params);
    },
    claimSeller: async (
      params: TestContractParamsWithoutMaps<
        SaleFlatPriceAlphTypes.Fields,
        { amount: bigint }
      >
    ): Promise<TestContractResultWithoutMaps<null>> => {
      return testMethod(this, "claimSeller", params);
    },
    claimSellerRefund: async (
      params: TestContractParamsWithoutMaps<
        SaleFlatPriceAlphTypes.Fields,
        { amount: bigint }
      >
    ): Promise<TestContractResultWithoutMaps<null>> => {
      return testMethod(this, "claimSellerRefund", params);
    },
    buy: async (
      params: TestContractParamsWithoutMaps<
        SaleFlatPriceAlphTypes.Fields,
        { bidAmount: bigint; wlMerkleProof: HexString }
      >
    ): Promise<TestContractResultWithoutMaps<null>> => {
      return testMethod(this, "buy", params);
    },
    calculateSaleTokensReceivedPerBidTokens: async (
      params: TestContractParamsWithoutMaps<
        SaleFlatPriceAlphTypes.Fields,
        { bidAmount: bigint }
      >
    ): Promise<TestContractResultWithoutMaps<bigint>> => {
      return testMethod(
        this,
        "calculateSaleTokensReceivedPerBidTokens",
        params
      );
    },
    assertPriceInRange: async (
      params: Omit<
        TestContractParamsWithoutMaps<SaleFlatPriceAlphTypes.Fields, never>,
        "testArgs"
      >
    ): Promise<TestContractResultWithoutMaps<null>> => {
      return testMethod(this, "assertPriceInRange", params);
    },
    assertBidAmountInRange: async (
      params: TestContractParamsWithoutMaps<
        SaleFlatPriceAlphTypes.Fields,
        { bidAmount: bigint }
      >
    ): Promise<TestContractResultWithoutMaps<null>> => {
      return testMethod(this, "assertBidAmountInRange", params);
    },
    assertSaleAmountInRange: async (
      params: Omit<
        TestContractParamsWithoutMaps<SaleFlatPriceAlphTypes.Fields, never>,
        "testArgs"
      >
    ): Promise<TestContractResultWithoutMaps<null>> => {
      return testMethod(this, "assertSaleAmountInRange", params);
    },
    createAccount: async (
      params: TestContractParamsWithoutMaps<
        SaleFlatPriceAlphTypes.Fields,
        {
          account: Address;
          encodedImmFields: HexString;
          encodedMutFields: HexString;
        }
      >
    ): Promise<TestContractResultWithoutMaps<null>> => {
      return testMethod(this, "createAccount", params);
    },
    destroyAccount: async (
      params: TestContractParamsWithoutMaps<
        SaleFlatPriceAlphTypes.Fields,
        { account: Address }
      >
    ): Promise<TestContractResultWithoutMaps<null>> => {
      return testMethod(this, "destroyAccount", params);
    },
    assertAccountExists: async (
      params: TestContractParamsWithoutMaps<
        SaleFlatPriceAlphTypes.Fields,
        { account: Address }
      >
    ): Promise<TestContractResultWithoutMaps<null>> => {
      return testMethod(this, "assertAccountExists", params);
    },
    accountExists: async (
      params: TestContractParamsWithoutMaps<
        SaleFlatPriceAlphTypes.Fields,
        { account: Address }
      >
    ): Promise<TestContractResultWithoutMaps<boolean>> => {
      return testMethod(this, "accountExists", params);
    },
    getSubContractId: async (
      params: TestContractParamsWithoutMaps<
        SaleFlatPriceAlphTypes.Fields,
        { account: Address }
      >
    ): Promise<TestContractResultWithoutMaps<HexString>> => {
      return testMethod(this, "getSubContractId", params);
    },
    claim: async (
      params: TestContractParamsWithoutMaps<
        SaleFlatPriceAlphTypes.Fields,
        { amount: bigint }
      >
    ): Promise<TestContractResultWithoutMaps<null>> => {
      return testMethod(this, "claim", params);
    },
    claimRefund: async (
      params: TestContractParamsWithoutMaps<
        SaleFlatPriceAlphTypes.Fields,
        { amount: bigint }
      >
    ): Promise<TestContractResultWithoutMaps<null>> => {
      return testMethod(this, "claimRefund", params);
    },
    setMerkleRoot: async (
      params: TestContractParamsWithoutMaps<
        SaleFlatPriceAlphTypes.Fields,
        { newMerkleRoot: HexString }
      >
    ): Promise<TestContractResultWithoutMaps<null>> => {
      return testMethod(this, "setMerkleRoot", params);
    },
    assertSaleLive: async (
      params: Omit<
        TestContractParamsWithoutMaps<SaleFlatPriceAlphTypes.Fields, never>,
        "testArgs"
      >
    ): Promise<TestContractResultWithoutMaps<null>> => {
      return testMethod(this, "assertSaleLive", params);
    },
    assertSaleFinished: async (
      params: Omit<
        TestContractParamsWithoutMaps<SaleFlatPriceAlphTypes.Fields, never>,
        "testArgs"
      >
    ): Promise<TestContractResultWithoutMaps<null>> => {
      return testMethod(this, "assertSaleFinished", params);
    },
    assertCanClaim: async (
      params: Omit<
        TestContractParamsWithoutMaps<SaleFlatPriceAlphTypes.Fields, never>,
        "testArgs"
      >
    ): Promise<TestContractResultWithoutMaps<null>> => {
      return testMethod(this, "assertCanClaim", params);
    },
    assertCanClaimRefund: async (
      params: Omit<
        TestContractParamsWithoutMaps<SaleFlatPriceAlphTypes.Fields, never>,
        "testArgs"
      >
    ): Promise<TestContractResultWithoutMaps<null>> => {
      return testMethod(this, "assertCanClaimRefund", params);
    },
    assertSaleNotStarted: async (
      params: Omit<
        TestContractParamsWithoutMaps<SaleFlatPriceAlphTypes.Fields, never>,
        "testArgs"
      >
    ): Promise<TestContractResultWithoutMaps<null>> => {
      return testMethod(this, "assertSaleNotStarted", params);
    },
    isSaleLive: async (
      params: Omit<
        TestContractParamsWithoutMaps<SaleFlatPriceAlphTypes.Fields, never>,
        "testArgs"
      >
    ): Promise<TestContractResultWithoutMaps<boolean>> => {
      return testMethod(this, "isSaleLive", params);
    },
    isSaleFinished: async (
      params: Omit<
        TestContractParamsWithoutMaps<SaleFlatPriceAlphTypes.Fields, never>,
        "testArgs"
      >
    ): Promise<TestContractResultWithoutMaps<boolean>> => {
      return testMethod(this, "isSaleFinished", params);
    },
    isSaleSuccess: async (
      params: Omit<
        TestContractParamsWithoutMaps<SaleFlatPriceAlphTypes.Fields, never>,
        "testArgs"
      >
    ): Promise<TestContractResultWithoutMaps<boolean>> => {
      return testMethod(this, "isSaleSuccess", params);
    },
    isWhitelistSaleLive: async (
      params: Omit<
        TestContractParamsWithoutMaps<SaleFlatPriceAlphTypes.Fields, never>,
        "testArgs"
      >
    ): Promise<TestContractResultWithoutMaps<boolean>> => {
      return testMethod(this, "isWhitelistSaleLive", params);
    },
    isWhitelistSale: async (
      params: Omit<
        TestContractParamsWithoutMaps<SaleFlatPriceAlphTypes.Fields, never>,
        "testArgs"
      >
    ): Promise<TestContractResultWithoutMaps<boolean>> => {
      return testMethod(this, "isWhitelistSale", params);
    },
    isCallerSaleOwner: async (
      params: TestContractParamsWithoutMaps<
        SaleFlatPriceAlphTypes.Fields,
        { caller: Address }
      >
    ): Promise<TestContractResultWithoutMaps<boolean>> => {
      return testMethod(this, "isCallerSaleOwner", params);
    },
    getSaleOwner: async (
      params: Omit<
        TestContractParamsWithoutMaps<SaleFlatPriceAlphTypes.Fields, never>,
        "testArgs"
      >
    ): Promise<TestContractResultWithoutMaps<Address>> => {
      return testMethod(this, "getSaleOwner", params);
    },
    getSaleStart: async (
      params: Omit<
        TestContractParamsWithoutMaps<SaleFlatPriceAlphTypes.Fields, never>,
        "testArgs"
      >
    ): Promise<TestContractResultWithoutMaps<bigint>> => {
      return testMethod(this, "getSaleStart", params);
    },
    getSaleEnd: async (
      params: Omit<
        TestContractParamsWithoutMaps<SaleFlatPriceAlphTypes.Fields, never>,
        "testArgs"
      >
    ): Promise<TestContractResultWithoutMaps<bigint>> => {
      return testMethod(this, "getSaleEnd", params);
    },
    getMinRaise: async (
      params: Omit<
        TestContractParamsWithoutMaps<SaleFlatPriceAlphTypes.Fields, never>,
        "testArgs"
      >
    ): Promise<TestContractResultWithoutMaps<bigint>> => {
      return testMethod(this, "getMinRaise", params);
    },
    getMaxRaise: async (
      params: Omit<
        TestContractParamsWithoutMaps<SaleFlatPriceAlphTypes.Fields, never>,
        "testArgs"
      >
    ): Promise<TestContractResultWithoutMaps<bigint>> => {
      return testMethod(this, "getMaxRaise", params);
    },
    getSaleTokenId: async (
      params: Omit<
        TestContractParamsWithoutMaps<SaleFlatPriceAlphTypes.Fields, never>,
        "testArgs"
      >
    ): Promise<TestContractResultWithoutMaps<HexString>> => {
      return testMethod(this, "getSaleTokenId", params);
    },
    getBidTokenId: async (
      params: Omit<
        TestContractParamsWithoutMaps<SaleFlatPriceAlphTypes.Fields, never>,
        "testArgs"
      >
    ): Promise<TestContractResultWithoutMaps<HexString>> => {
      return testMethod(this, "getBidTokenId", params);
    },
    getWhitelistSaleStart: async (
      params: Omit<
        TestContractParamsWithoutMaps<SaleFlatPriceAlphTypes.Fields, never>,
        "testArgs"
      >
    ): Promise<TestContractResultWithoutMaps<bigint>> => {
      return testMethod(this, "getWhitelistSaleStart", params);
    },
    getWhitelistSaleEnd: async (
      params: Omit<
        TestContractParamsWithoutMaps<SaleFlatPriceAlphTypes.Fields, never>,
        "testArgs"
      >
    ): Promise<TestContractResultWithoutMaps<bigint>> => {
      return testMethod(this, "getWhitelistSaleEnd", params);
    },
    getTokensSold: async (
      params: Omit<
        TestContractParamsWithoutMaps<SaleFlatPriceAlphTypes.Fields, never>,
        "testArgs"
      >
    ): Promise<TestContractResultWithoutMaps<bigint>> => {
      return testMethod(this, "getTokensSold", params);
    },
    getTotalRaised: async (
      params: Omit<
        TestContractParamsWithoutMaps<SaleFlatPriceAlphTypes.Fields, never>,
        "testArgs"
      >
    ): Promise<TestContractResultWithoutMaps<bigint>> => {
      return testMethod(this, "getTotalRaised", params);
    },
    getMerkleRoot: async (
      params: Omit<
        TestContractParamsWithoutMaps<SaleFlatPriceAlphTypes.Fields, never>,
        "testArgs"
      >
    ): Promise<TestContractResultWithoutMaps<HexString>> => {
      return testMethod(this, "getMerkleRoot", params);
    },
    updateRoot: async (
      params: TestContractParamsWithoutMaps<
        SaleFlatPriceAlphTypes.Fields,
        { newMerkleRoot: HexString }
      >
    ): Promise<TestContractResultWithoutMaps<null>> => {
      return testMethod(this, "updateRoot", params);
    },
    verify: async (
      params: TestContractParamsWithoutMaps<
        SaleFlatPriceAlphTypes.Fields,
        { proof: HexString; dataHash: HexString }
      >
    ): Promise<TestContractResultWithoutMaps<boolean>> => {
      return testMethod(this, "verify", params);
    },
    hashPair: async (
      params: TestContractParamsWithoutMaps<
        SaleFlatPriceAlphTypes.Fields,
        { a: HexString; b: HexString }
      >
    ): Promise<TestContractResultWithoutMaps<HexString>> => {
      return testMethod(this, "hashPair", params);
    },
    hash: async (
      params: TestContractParamsWithoutMaps<
        SaleFlatPriceAlphTypes.Fields,
        { dataToHash: HexString }
      >
    ): Promise<TestContractResultWithoutMaps<HexString>> => {
      return testMethod(this, "hash", params);
    },
  };
}

// Use this object to test and deploy the contract
export const SaleFlatPriceAlph = new Factory(
  Contract.fromJson(
    SaleFlatPriceAlphContractJson,
    "",
    "4faf86493222343633c41282aefa03e6902b4e9472673f6a56b12c4694b93ab9"
  )
);

// Use this class to interact with the blockchain
export class SaleFlatPriceAlphInstance extends ContractInstance {
  constructor(address: Address) {
    super(address);
  }

  async fetchState(): Promise<SaleFlatPriceAlphTypes.State> {
    return fetchContractState(SaleFlatPriceAlph, this);
  }

  async getContractEventsCurrentCount(): Promise<number> {
    return getContractEventsCurrentCount(this.address);
  }

  subscribeBuyEvent(
    options: EventSubscribeOptions<SaleFlatPriceAlphTypes.BuyEvent>,
    fromCount?: number
  ): EventSubscription {
    return subscribeContractEvent(
      SaleFlatPriceAlph.contract,
      this,
      options,
      "Buy",
      fromCount
    );
  }

  subscribeAccountCreateEvent(
    options: EventSubscribeOptions<SaleFlatPriceAlphTypes.AccountCreateEvent>,
    fromCount?: number
  ): EventSubscription {
    return subscribeContractEvent(
      SaleFlatPriceAlph.contract,
      this,
      options,
      "AccountCreate",
      fromCount
    );
  }

  subscribeAccountDestroyEvent(
    options: EventSubscribeOptions<SaleFlatPriceAlphTypes.AccountDestroyEvent>,
    fromCount?: number
  ): EventSubscription {
    return subscribeContractEvent(
      SaleFlatPriceAlph.contract,
      this,
      options,
      "AccountDestroy",
      fromCount
    );
  }

  subscribeClaimBuyerEvent(
    options: EventSubscribeOptions<SaleFlatPriceAlphTypes.ClaimBuyerEvent>,
    fromCount?: number
  ): EventSubscription {
    return subscribeContractEvent(
      SaleFlatPriceAlph.contract,
      this,
      options,
      "ClaimBuyer",
      fromCount
    );
  }

  subscribeClaimBuyerRefundEvent(
    options: EventSubscribeOptions<SaleFlatPriceAlphTypes.ClaimBuyerRefundEvent>,
    fromCount?: number
  ): EventSubscription {
    return subscribeContractEvent(
      SaleFlatPriceAlph.contract,
      this,
      options,
      "ClaimBuyerRefund",
      fromCount
    );
  }

  subscribeClaimSellerEvent(
    options: EventSubscribeOptions<SaleFlatPriceAlphTypes.ClaimSellerEvent>,
    fromCount?: number
  ): EventSubscription {
    return subscribeContractEvent(
      SaleFlatPriceAlph.contract,
      this,
      options,
      "ClaimSeller",
      fromCount
    );
  }

  subscribeClaimSellerRefundEvent(
    options: EventSubscribeOptions<SaleFlatPriceAlphTypes.ClaimSellerRefundEvent>,
    fromCount?: number
  ): EventSubscription {
    return subscribeContractEvent(
      SaleFlatPriceAlph.contract,
      this,
      options,
      "ClaimSellerRefund",
      fromCount
    );
  }

  subscribeUpdateRootEvent(
    options: EventSubscribeOptions<SaleFlatPriceAlphTypes.UpdateRootEvent>,
    fromCount?: number
  ): EventSubscription {
    return subscribeContractEvent(
      SaleFlatPriceAlph.contract,
      this,
      options,
      "UpdateRoot",
      fromCount
    );
  }

  subscribeAllEvents(
    options: EventSubscribeOptions<
      | SaleFlatPriceAlphTypes.BuyEvent
      | SaleFlatPriceAlphTypes.AccountCreateEvent
      | SaleFlatPriceAlphTypes.AccountDestroyEvent
      | SaleFlatPriceAlphTypes.ClaimBuyerEvent
      | SaleFlatPriceAlphTypes.ClaimBuyerRefundEvent
      | SaleFlatPriceAlphTypes.ClaimSellerEvent
      | SaleFlatPriceAlphTypes.ClaimSellerRefundEvent
      | SaleFlatPriceAlphTypes.UpdateRootEvent
    >,
    fromCount?: number
  ): EventSubscription {
    return subscribeContractEvents(
      SaleFlatPriceAlph.contract,
      this,
      options,
      fromCount
    );
  }

  methods = {
    calculateSaleTokensReceivedPerBidTokens: async (
      params: SaleFlatPriceAlphTypes.CallMethodParams<"calculateSaleTokensReceivedPerBidTokens">
    ): Promise<
      SaleFlatPriceAlphTypes.CallMethodResult<"calculateSaleTokensReceivedPerBidTokens">
    > => {
      return callMethod(
        SaleFlatPriceAlph,
        this,
        "calculateSaleTokensReceivedPerBidTokens",
        params,
        getContractByCodeHash
      );
    },
    accountExists: async (
      params: SaleFlatPriceAlphTypes.CallMethodParams<"accountExists">
    ): Promise<SaleFlatPriceAlphTypes.CallMethodResult<"accountExists">> => {
      return callMethod(
        SaleFlatPriceAlph,
        this,
        "accountExists",
        params,
        getContractByCodeHash
      );
    },
    getSubContractId: async (
      params: SaleFlatPriceAlphTypes.CallMethodParams<"getSubContractId">
    ): Promise<SaleFlatPriceAlphTypes.CallMethodResult<"getSubContractId">> => {
      return callMethod(
        SaleFlatPriceAlph,
        this,
        "getSubContractId",
        params,
        getContractByCodeHash
      );
    },
    isSaleLive: async (
      params?: SaleFlatPriceAlphTypes.CallMethodParams<"isSaleLive">
    ): Promise<SaleFlatPriceAlphTypes.CallMethodResult<"isSaleLive">> => {
      return callMethod(
        SaleFlatPriceAlph,
        this,
        "isSaleLive",
        params === undefined ? {} : params,
        getContractByCodeHash
      );
    },
    isSaleFinished: async (
      params?: SaleFlatPriceAlphTypes.CallMethodParams<"isSaleFinished">
    ): Promise<SaleFlatPriceAlphTypes.CallMethodResult<"isSaleFinished">> => {
      return callMethod(
        SaleFlatPriceAlph,
        this,
        "isSaleFinished",
        params === undefined ? {} : params,
        getContractByCodeHash
      );
    },
    isSaleSuccess: async (
      params?: SaleFlatPriceAlphTypes.CallMethodParams<"isSaleSuccess">
    ): Promise<SaleFlatPriceAlphTypes.CallMethodResult<"isSaleSuccess">> => {
      return callMethod(
        SaleFlatPriceAlph,
        this,
        "isSaleSuccess",
        params === undefined ? {} : params,
        getContractByCodeHash
      );
    },
    isWhitelistSaleLive: async (
      params?: SaleFlatPriceAlphTypes.CallMethodParams<"isWhitelistSaleLive">
    ): Promise<
      SaleFlatPriceAlphTypes.CallMethodResult<"isWhitelistSaleLive">
    > => {
      return callMethod(
        SaleFlatPriceAlph,
        this,
        "isWhitelistSaleLive",
        params === undefined ? {} : params,
        getContractByCodeHash
      );
    },
    isWhitelistSale: async (
      params?: SaleFlatPriceAlphTypes.CallMethodParams<"isWhitelistSale">
    ): Promise<SaleFlatPriceAlphTypes.CallMethodResult<"isWhitelistSale">> => {
      return callMethod(
        SaleFlatPriceAlph,
        this,
        "isWhitelistSale",
        params === undefined ? {} : params,
        getContractByCodeHash
      );
    },
    isCallerSaleOwner: async (
      params: SaleFlatPriceAlphTypes.CallMethodParams<"isCallerSaleOwner">
    ): Promise<
      SaleFlatPriceAlphTypes.CallMethodResult<"isCallerSaleOwner">
    > => {
      return callMethod(
        SaleFlatPriceAlph,
        this,
        "isCallerSaleOwner",
        params,
        getContractByCodeHash
      );
    },
    getSaleOwner: async (
      params?: SaleFlatPriceAlphTypes.CallMethodParams<"getSaleOwner">
    ): Promise<SaleFlatPriceAlphTypes.CallMethodResult<"getSaleOwner">> => {
      return callMethod(
        SaleFlatPriceAlph,
        this,
        "getSaleOwner",
        params === undefined ? {} : params,
        getContractByCodeHash
      );
    },
    getSaleStart: async (
      params?: SaleFlatPriceAlphTypes.CallMethodParams<"getSaleStart">
    ): Promise<SaleFlatPriceAlphTypes.CallMethodResult<"getSaleStart">> => {
      return callMethod(
        SaleFlatPriceAlph,
        this,
        "getSaleStart",
        params === undefined ? {} : params,
        getContractByCodeHash
      );
    },
    getSaleEnd: async (
      params?: SaleFlatPriceAlphTypes.CallMethodParams<"getSaleEnd">
    ): Promise<SaleFlatPriceAlphTypes.CallMethodResult<"getSaleEnd">> => {
      return callMethod(
        SaleFlatPriceAlph,
        this,
        "getSaleEnd",
        params === undefined ? {} : params,
        getContractByCodeHash
      );
    },
    getMinRaise: async (
      params?: SaleFlatPriceAlphTypes.CallMethodParams<"getMinRaise">
    ): Promise<SaleFlatPriceAlphTypes.CallMethodResult<"getMinRaise">> => {
      return callMethod(
        SaleFlatPriceAlph,
        this,
        "getMinRaise",
        params === undefined ? {} : params,
        getContractByCodeHash
      );
    },
    getMaxRaise: async (
      params?: SaleFlatPriceAlphTypes.CallMethodParams<"getMaxRaise">
    ): Promise<SaleFlatPriceAlphTypes.CallMethodResult<"getMaxRaise">> => {
      return callMethod(
        SaleFlatPriceAlph,
        this,
        "getMaxRaise",
        params === undefined ? {} : params,
        getContractByCodeHash
      );
    },
    getSaleTokenId: async (
      params?: SaleFlatPriceAlphTypes.CallMethodParams<"getSaleTokenId">
    ): Promise<SaleFlatPriceAlphTypes.CallMethodResult<"getSaleTokenId">> => {
      return callMethod(
        SaleFlatPriceAlph,
        this,
        "getSaleTokenId",
        params === undefined ? {} : params,
        getContractByCodeHash
      );
    },
    getBidTokenId: async (
      params?: SaleFlatPriceAlphTypes.CallMethodParams<"getBidTokenId">
    ): Promise<SaleFlatPriceAlphTypes.CallMethodResult<"getBidTokenId">> => {
      return callMethod(
        SaleFlatPriceAlph,
        this,
        "getBidTokenId",
        params === undefined ? {} : params,
        getContractByCodeHash
      );
    },
    getWhitelistSaleStart: async (
      params?: SaleFlatPriceAlphTypes.CallMethodParams<"getWhitelistSaleStart">
    ): Promise<
      SaleFlatPriceAlphTypes.CallMethodResult<"getWhitelistSaleStart">
    > => {
      return callMethod(
        SaleFlatPriceAlph,
        this,
        "getWhitelistSaleStart",
        params === undefined ? {} : params,
        getContractByCodeHash
      );
    },
    getWhitelistSaleEnd: async (
      params?: SaleFlatPriceAlphTypes.CallMethodParams<"getWhitelistSaleEnd">
    ): Promise<
      SaleFlatPriceAlphTypes.CallMethodResult<"getWhitelistSaleEnd">
    > => {
      return callMethod(
        SaleFlatPriceAlph,
        this,
        "getWhitelistSaleEnd",
        params === undefined ? {} : params,
        getContractByCodeHash
      );
    },
    getTokensSold: async (
      params?: SaleFlatPriceAlphTypes.CallMethodParams<"getTokensSold">
    ): Promise<SaleFlatPriceAlphTypes.CallMethodResult<"getTokensSold">> => {
      return callMethod(
        SaleFlatPriceAlph,
        this,
        "getTokensSold",
        params === undefined ? {} : params,
        getContractByCodeHash
      );
    },
    getTotalRaised: async (
      params?: SaleFlatPriceAlphTypes.CallMethodParams<"getTotalRaised">
    ): Promise<SaleFlatPriceAlphTypes.CallMethodResult<"getTotalRaised">> => {
      return callMethod(
        SaleFlatPriceAlph,
        this,
        "getTotalRaised",
        params === undefined ? {} : params,
        getContractByCodeHash
      );
    },
    getMerkleRoot: async (
      params?: SaleFlatPriceAlphTypes.CallMethodParams<"getMerkleRoot">
    ): Promise<SaleFlatPriceAlphTypes.CallMethodResult<"getMerkleRoot">> => {
      return callMethod(
        SaleFlatPriceAlph,
        this,
        "getMerkleRoot",
        params === undefined ? {} : params,
        getContractByCodeHash
      );
    },
  };

  async multicall<Calls extends SaleFlatPriceAlphTypes.MultiCallParams>(
    calls: Calls
  ): Promise<SaleFlatPriceAlphTypes.MultiCallResults<Calls>> {
    return (await multicallMethods(
      SaleFlatPriceAlph,
      this,
      calls,
      getContractByCodeHash
    )) as SaleFlatPriceAlphTypes.MultiCallResults<Calls>;
  }
}
