/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */

import {
  Address,
  Contract,
  ContractState,
  TestContractResult,
  HexString,
  ContractFactory,
  EventSubscribeOptions,
  EventSubscription,
  CallContractParams,
  CallContractResult,
  TestContractParams,
  ContractEvent,
  subscribeContractEvent,
  subscribeContractEvents,
  testMethod,
  callMethod,
  multicallMethods,
  fetchContractState,
  ContractInstance,
  getContractEventsCurrentCount,
  TestContractParamsWithoutMaps,
  TestContractResultWithoutMaps,
} from "@alephium/web3";
import { default as SaleFlatPriceAlphV2ContractJson } from "../launch_sale_v2/SaleFlatPriceAlphV2.ral.json";
import { getContractByCodeHash } from "./contracts";

// Custom types for the contract
export namespace SaleFlatPriceAlphV2Types {
  export type Fields = {
    rewardDistributor: HexString;
    saleOwner: Address;
    accountTemplateId: HexString;
    tokenPrice: bigint;
    minRaise: bigint;
    maxRaise: bigint;
    saleTokenId: HexString;
    saleTokenTotalAmount: bigint;
    bidTokenId: HexString;
    saleStart: bigint;
    saleEnd: bigint;
    whitelistSaleStart: bigint;
    whitelistSaleEnd: bigint;
    whitelistBuyerMaxBid: bigint;
    tokensSold: bigint;
    totalRaised: bigint;
    merkleRoot: HexString;
    publicSaleMaxBid: bigint;
    sellerClaimed: bigint;
    upfrontRelease: bigint;
    vestingEnd: bigint;
    cliffEnd: bigint;
  };

  export type State = ContractState<Fields>;

  export type BuyEvent = ContractEvent<{
    account: Address;
    buyBidAmount: bigint;
    buyTokenAmount: bigint;
  }>;
  export type UpdateWhitelistBuyerMaxBidEvent = ContractEvent<{
    caller: Address;
    newPublicSaleMaxBid: bigint;
    oldPublicSaleMaxBid: bigint;
  }>;
  export type UpdatePublicSaleMaxBidEvent = ContractEvent<{
    caller: Address;
    newSellerClaimed: bigint;
    oldSellerClaimed: bigint;
  }>;
  export type UpdateUpfrontReleaseEvent = ContractEvent<{
    caller: Address;
    newUpfrontRelease: bigint;
    oldUpfrontRelease: bigint;
  }>;
  export type UpdateVestingEndEvent = ContractEvent<{
    caller: Address;
    newVestingEnd: bigint;
    oldVestingEnd: bigint;
  }>;
  export type UpdateCliffEndEvent = ContractEvent<{
    caller: Address;
    newCliffEnd: bigint;
    oldCliffEnd: bigint;
  }>;
  export type AccountCreateEvent = ContractEvent<{
    account: Address;
    contractId: HexString;
  }>;
  export type AccountDestroyEvent = ContractEvent<{
    account: Address;
    contractId: HexString;
  }>;
  export type ClaimBuyerEvent = ContractEvent<{
    account: Address;
    saleTokenAmount: bigint;
  }>;
  export type ClaimBuyerRefundEvent = ContractEvent<{
    account: Address;
    bidTokenAmount: bigint;
  }>;
  export type ClaimSellerEvent = ContractEvent<{
    account: Address;
    bidTokenAmount: bigint;
  }>;
  export type ClaimSellerRefundEvent = ContractEvent<{
    account: Address;
    saleTokenAmount: bigint;
  }>;
  export type SaleDatesUpdateEvent = ContractEvent<{
    caller: Address;
    newSaleStartDate: bigint;
    oldSaleStartDate: bigint;
    newSaleEndDate: bigint;
    oldSaleEndDate: bigint;
  }>;
  export type WhitelistSaleDatesUpdateEvent = ContractEvent<{
    caller: Address;
    newWLSaleStartDate: bigint;
    oldWLSaleStartDate: bigint;
    newWLSaleEndDate: bigint;
    oldWLSaleEndDate: bigint;
  }>;
  export type UpdateRootEvent = ContractEvent<{
    newMerkleRoot: HexString;
    updatedBy: Address;
  }>;

  export interface CallMethodTable {
    calculateClaimableAmount: {
      params: CallContractParams<{ buyerAccount: HexString }>;
      result: CallContractResult<bigint>;
    };
    calculateSaleTokensReceivedPerBidTokens: {
      params: CallContractParams<{ bidAmount: bigint }>;
      result: CallContractResult<bigint>;
    };
    checkIsWhitelisted: {
      params: CallContractParams<{
        account: Address;
        wlMerkleProof: HexString;
      }>;
      result: CallContractResult<boolean>;
    };
    accountExists: {
      params: CallContractParams<{ account: Address }>;
      result: CallContractResult<boolean>;
    };
    getSubContractId: {
      params: CallContractParams<{ account: Address }>;
      result: CallContractResult<HexString>;
    };
    isSaleLive: {
      params: Omit<CallContractParams<{}>, "args">;
      result: CallContractResult<boolean>;
    };
    isSaleFinished: {
      params: Omit<CallContractParams<{}>, "args">;
      result: CallContractResult<boolean>;
    };
    isSaleSuccess: {
      params: Omit<CallContractParams<{}>, "args">;
      result: CallContractResult<boolean>;
    };
    isWhitelistSaleLive: {
      params: Omit<CallContractParams<{}>, "args">;
      result: CallContractResult<boolean>;
    };
    isWhitelistSale: {
      params: Omit<CallContractParams<{}>, "args">;
      result: CallContractResult<boolean>;
    };
    isCallerSaleOwner: {
      params: CallContractParams<{ caller: Address }>;
      result: CallContractResult<boolean>;
    };
    getSaleOwner: {
      params: Omit<CallContractParams<{}>, "args">;
      result: CallContractResult<Address>;
    };
    getSaleStart: {
      params: Omit<CallContractParams<{}>, "args">;
      result: CallContractResult<bigint>;
    };
    getSaleEnd: {
      params: Omit<CallContractParams<{}>, "args">;
      result: CallContractResult<bigint>;
    };
    getMinRaise: {
      params: Omit<CallContractParams<{}>, "args">;
      result: CallContractResult<bigint>;
    };
    getMaxRaise: {
      params: Omit<CallContractParams<{}>, "args">;
      result: CallContractResult<bigint>;
    };
    getSaleTokenId: {
      params: Omit<CallContractParams<{}>, "args">;
      result: CallContractResult<HexString>;
    };
    getBidTokenId: {
      params: Omit<CallContractParams<{}>, "args">;
      result: CallContractResult<HexString>;
    };
    getWhitelistSaleStart: {
      params: Omit<CallContractParams<{}>, "args">;
      result: CallContractResult<bigint>;
    };
    getWhitelistSaleEnd: {
      params: Omit<CallContractParams<{}>, "args">;
      result: CallContractResult<bigint>;
    };
    getTokensSold: {
      params: Omit<CallContractParams<{}>, "args">;
      result: CallContractResult<bigint>;
    };
    getTotalRaised: {
      params: Omit<CallContractParams<{}>, "args">;
      result: CallContractResult<bigint>;
    };
    getMerkleRoot: {
      params: Omit<CallContractParams<{}>, "args">;
      result: CallContractResult<HexString>;
    };
  }
  export type CallMethodParams<T extends keyof CallMethodTable> =
    CallMethodTable[T]["params"];
  export type CallMethodResult<T extends keyof CallMethodTable> =
    CallMethodTable[T]["result"];
  export type MultiCallParams = Partial<{
    [Name in keyof CallMethodTable]: CallMethodTable[Name]["params"];
  }>;
  export type MultiCallResults<T extends MultiCallParams> = {
    [MaybeName in keyof T]: MaybeName extends keyof CallMethodTable
      ? CallMethodTable[MaybeName]["result"]
      : undefined;
  };
}

class Factory extends ContractFactory<
  SaleFlatPriceAlphV2Instance,
  SaleFlatPriceAlphV2Types.Fields
> {
  getInitialFieldsWithDefaultValues() {
    return this.contract.getInitialFieldsWithDefaultValues() as SaleFlatPriceAlphV2Types.Fields;
  }

  eventIndex = {
    Buy: 0,
    UpdateWhitelistBuyerMaxBid: 1,
    UpdatePublicSaleMaxBid: 2,
    UpdateUpfrontRelease: 3,
    UpdateVestingEnd: 4,
    UpdateCliffEnd: 5,
    AccountCreate: 6,
    AccountDestroy: 7,
    ClaimBuyer: 8,
    ClaimBuyerRefund: 9,
    ClaimSeller: 10,
    ClaimSellerRefund: 11,
    SaleDatesUpdate: 12,
    WhitelistSaleDatesUpdate: 13,
    UpdateRoot: 14,
  };
  consts = {
    ErrorCodes: {
      PriceMoreThanMax: BigInt(601),
      PriceLessThanMin: BigInt(602),
      BidMoreThanMax: BigInt(603),
      BidLessThanMin: BigInt(604),
      InvalidClaimAmount: BigInt(605),
      SaleTokenTotalExceeded: BigInt(606),
      SaleOwnerCanNotBid: BigInt(607),
      BuyerNotWhitelisted: BigInt(608),
      SaleTokenMoreThan18Decimal: BigInt(609),
      SaleAmountSmallerThanMin: BigInt(610),
      SaleAmountLargerThanMax: BigInt(611),
      SellerAlreadyClaimed: BigInt(612),
      ClaimsNotStarted: BigInt(613),
      UpfrontReleaseOutOfRange: BigInt(614),
      VestingEndOutOfRange: BigInt(615),
      CliffEndOutOfRange: BigInt(616),
    },
    AccountErrorCodes: {
      AccountAlreadyExists: BigInt(12001),
      AccountDoesNotExists: BigInt(12002),
    },
    MerkleProofErrorCodes: {
      InvalidProofSize: BigInt(11001),
      InvalidDataHash: BigInt(11002),
    },
    SaleBaseErrorCodes: {
      SaleNotLive: BigInt(1001),
      SaleNotFinished: BigInt(1002),
      SaleClaimNotAvailable: BigInt(1003),
      SaleRefundNotAvailable: BigInt(1004),
      SaleCanNotBeEditedAtThisTime: BigInt(1005),
      SaleUpdateUnauthorized: BigInt(1006),
      SaleIsNotWLSale: BigInt(1007),
      SaleStartMustBeInFuture: BigInt(1008),
      SaleEndMustBeAfterSaleStart: BigInt(1009),
      WLSaleStartMustBeWithinSaleDates: BigInt(1010),
      WLSaleEndMustBeWithinSaleDatesAndAfterWLSaleStart: BigInt(1011),
      InvalidMerkleRoot: BigInt(1012),
    },
  };

  at(address: string): SaleFlatPriceAlphV2Instance {
    return new SaleFlatPriceAlphV2Instance(address);
  }

  tests = {
    claimBuyer: async (
      params: TestContractParamsWithoutMaps<
        SaleFlatPriceAlphV2Types.Fields,
        { caller: Address; amount: bigint }
      >
    ): Promise<TestContractResultWithoutMaps<null>> => {
      return testMethod(this, "claimBuyer", params);
    },
    claimBuyerRefund: async (
      params: TestContractParamsWithoutMaps<
        SaleFlatPriceAlphV2Types.Fields,
        { caller: Address; amount: bigint }
      >
    ): Promise<TestContractResultWithoutMaps<null>> => {
      return testMethod(this, "claimBuyerRefund", params);
    },
    claimSeller: async (
      params: TestContractParamsWithoutMaps<
        SaleFlatPriceAlphV2Types.Fields,
        { amount: bigint }
      >
    ): Promise<TestContractResultWithoutMaps<null>> => {
      return testMethod(this, "claimSeller", params);
    },
    claimSellerRefund: async (
      params: TestContractParamsWithoutMaps<
        SaleFlatPriceAlphV2Types.Fields,
        { amount: bigint }
      >
    ): Promise<TestContractResultWithoutMaps<null>> => {
      return testMethod(this, "claimSellerRefund", params);
    },
    buy: async (
      params: TestContractParamsWithoutMaps<
        SaleFlatPriceAlphV2Types.Fields,
        { bidAmount: bigint; wlMerkleProof: HexString }
      >
    ): Promise<TestContractResultWithoutMaps<null>> => {
      return testMethod(this, "buy", params);
    },
    checkBidLimit: async (
      params: TestContractParamsWithoutMaps<
        SaleFlatPriceAlphV2Types.Fields,
        { account: Address; bidAmount: bigint; maxBid: bigint }
      >
    ): Promise<TestContractResultWithoutMaps<null>> => {
      return testMethod(this, "checkBidLimit", params);
    },
    calculateClaimableAmount: async (
      params: TestContractParamsWithoutMaps<
        SaleFlatPriceAlphV2Types.Fields,
        { buyerAccount: HexString }
      >
    ): Promise<TestContractResultWithoutMaps<bigint>> => {
      return testMethod(this, "calculateClaimableAmount", params);
    },
    calculateSaleTokensReceivedPerBidTokens: async (
      params: TestContractParamsWithoutMaps<
        SaleFlatPriceAlphV2Types.Fields,
        { bidAmount: bigint }
      >
    ): Promise<TestContractResultWithoutMaps<bigint>> => {
      return testMethod(
        this,
        "calculateSaleTokensReceivedPerBidTokens",
        params
      );
    },
    checkIsWhitelisted: async (
      params: TestContractParamsWithoutMaps<
        SaleFlatPriceAlphV2Types.Fields,
        { account: Address; wlMerkleProof: HexString }
      >
    ): Promise<TestContractResultWithoutMaps<boolean>> => {
      return testMethod(this, "checkIsWhitelisted", params);
    },
    setWhitelistBuyerMaxBid: async (
      params: TestContractParamsWithoutMaps<
        SaleFlatPriceAlphV2Types.Fields,
        { newWhitelistBuyerMaxBid: bigint }
      >
    ): Promise<TestContractResultWithoutMaps<null>> => {
      return testMethod(this, "setWhitelistBuyerMaxBid", params);
    },
    setPublicSaleMaxBid: async (
      params: TestContractParamsWithoutMaps<
        SaleFlatPriceAlphV2Types.Fields,
        { newPublicSaleMaxBid: bigint }
      >
    ): Promise<TestContractResultWithoutMaps<null>> => {
      return testMethod(this, "setPublicSaleMaxBid", params);
    },
    setVestingEnd: async (
      params: TestContractParamsWithoutMaps<
        SaleFlatPriceAlphV2Types.Fields,
        { newVestingEnd: bigint }
      >
    ): Promise<TestContractResultWithoutMaps<null>> => {
      return testMethod(this, "setVestingEnd", params);
    },
    setUpfrontRelease: async (
      params: TestContractParamsWithoutMaps<
        SaleFlatPriceAlphV2Types.Fields,
        { newUpfrontRelease: bigint }
      >
    ): Promise<TestContractResultWithoutMaps<null>> => {
      return testMethod(this, "setUpfrontRelease", params);
    },
    setCliffEnd: async (
      params: TestContractParamsWithoutMaps<
        SaleFlatPriceAlphV2Types.Fields,
        { newCliffEnd: bigint }
      >
    ): Promise<TestContractResultWithoutMaps<null>> => {
      return testMethod(this, "setCliffEnd", params);
    },
    assertPriceInRange: async (
      params: Omit<
        TestContractParamsWithoutMaps<SaleFlatPriceAlphV2Types.Fields, never>,
        "testArgs"
      >
    ): Promise<TestContractResultWithoutMaps<null>> => {
      return testMethod(this, "assertPriceInRange", params);
    },
    assertMaxBidAmountInRange: async (
      params: TestContractParamsWithoutMaps<
        SaleFlatPriceAlphV2Types.Fields,
        { maxBidAmount: bigint }
      >
    ): Promise<TestContractResultWithoutMaps<null>> => {
      return testMethod(this, "assertMaxBidAmountInRange", params);
    },
    assertBidAmountInRange: async (
      params: TestContractParamsWithoutMaps<
        SaleFlatPriceAlphV2Types.Fields,
        { bidAmount: bigint }
      >
    ): Promise<TestContractResultWithoutMaps<null>> => {
      return testMethod(this, "assertBidAmountInRange", params);
    },
    assertSaleAmountInRange: async (
      params: Omit<
        TestContractParamsWithoutMaps<SaleFlatPriceAlphV2Types.Fields, never>,
        "testArgs"
      >
    ): Promise<TestContractResultWithoutMaps<null>> => {
      return testMethod(this, "assertSaleAmountInRange", params);
    },
    createAccount: async (
      params: TestContractParamsWithoutMaps<
        SaleFlatPriceAlphV2Types.Fields,
        {
          account: Address;
          encodedImmFields: HexString;
          encodedMutFields: HexString;
        }
      >
    ): Promise<TestContractResultWithoutMaps<null>> => {
      return testMethod(this, "createAccount", params);
    },
    destroyAccount: async (
      params: TestContractParamsWithoutMaps<
        SaleFlatPriceAlphV2Types.Fields,
        { account: Address }
      >
    ): Promise<TestContractResultWithoutMaps<null>> => {
      return testMethod(this, "destroyAccount", params);
    },
    assertAccountExists: async (
      params: TestContractParamsWithoutMaps<
        SaleFlatPriceAlphV2Types.Fields,
        { account: Address }
      >
    ): Promise<TestContractResultWithoutMaps<null>> => {
      return testMethod(this, "assertAccountExists", params);
    },
    accountExists: async (
      params: TestContractParamsWithoutMaps<
        SaleFlatPriceAlphV2Types.Fields,
        { account: Address }
      >
    ): Promise<TestContractResultWithoutMaps<boolean>> => {
      return testMethod(this, "accountExists", params);
    },
    getSubContractId: async (
      params: TestContractParamsWithoutMaps<
        SaleFlatPriceAlphV2Types.Fields,
        { account: Address }
      >
    ): Promise<TestContractResultWithoutMaps<HexString>> => {
      return testMethod(this, "getSubContractId", params);
    },
    claim: async (
      params: TestContractParamsWithoutMaps<
        SaleFlatPriceAlphV2Types.Fields,
        { amount: bigint }
      >
    ): Promise<TestContractResultWithoutMaps<null>> => {
      return testMethod(this, "claim", params);
    },
    claimRefund: async (
      params: TestContractParamsWithoutMaps<
        SaleFlatPriceAlphV2Types.Fields,
        { amount: bigint }
      >
    ): Promise<TestContractResultWithoutMaps<null>> => {
      return testMethod(this, "claimRefund", params);
    },
    setMerkleRoot: async (
      params: TestContractParamsWithoutMaps<
        SaleFlatPriceAlphV2Types.Fields,
        { newMerkleRoot: HexString }
      >
    ): Promise<TestContractResultWithoutMaps<null>> => {
      return testMethod(this, "setMerkleRoot", params);
    },
    setSaleDates: async (
      params: TestContractParamsWithoutMaps<
        SaleFlatPriceAlphV2Types.Fields,
        {
          newSaleStart: bigint;
          newSaleEnd: bigint;
          newWhitelistSaleStart: bigint;
          newWhitelistSaleEnd: bigint;
        }
      >
    ): Promise<TestContractResultWithoutMaps<null>> => {
      return testMethod(this, "setSaleDates", params);
    },
    assertSaleLive: async (
      params: Omit<
        TestContractParamsWithoutMaps<SaleFlatPriceAlphV2Types.Fields, never>,
        "testArgs"
      >
    ): Promise<TestContractResultWithoutMaps<null>> => {
      return testMethod(this, "assertSaleLive", params);
    },
    assertSaleFinished: async (
      params: Omit<
        TestContractParamsWithoutMaps<SaleFlatPriceAlphV2Types.Fields, never>,
        "testArgs"
      >
    ): Promise<TestContractResultWithoutMaps<null>> => {
      return testMethod(this, "assertSaleFinished", params);
    },
    assertCanClaim: async (
      params: Omit<
        TestContractParamsWithoutMaps<SaleFlatPriceAlphV2Types.Fields, never>,
        "testArgs"
      >
    ): Promise<TestContractResultWithoutMaps<null>> => {
      return testMethod(this, "assertCanClaim", params);
    },
    assertCanClaimRefund: async (
      params: Omit<
        TestContractParamsWithoutMaps<SaleFlatPriceAlphV2Types.Fields, never>,
        "testArgs"
      >
    ): Promise<TestContractResultWithoutMaps<null>> => {
      return testMethod(this, "assertCanClaimRefund", params);
    },
    assertSaleEditable: async (
      params: Omit<
        TestContractParamsWithoutMaps<SaleFlatPriceAlphV2Types.Fields, never>,
        "testArgs"
      >
    ): Promise<TestContractResultWithoutMaps<null>> => {
      return testMethod(this, "assertSaleEditable", params);
    },
    assertValidSaleDates: async (
      params: TestContractParamsWithoutMaps<
        SaleFlatPriceAlphV2Types.Fields,
        { asSaleStart: bigint; asSaleEnd: bigint }
      >
    ): Promise<TestContractResultWithoutMaps<null>> => {
      return testMethod(this, "assertValidSaleDates", params);
    },
    assertValidWLSaleDates: async (
      params: TestContractParamsWithoutMaps<
        SaleFlatPriceAlphV2Types.Fields,
        {
          asSaleStart: bigint;
          asSaleEnd: bigint;
          asWLSaleStart: bigint;
          asWLSaleEnd: bigint;
        }
      >
    ): Promise<TestContractResultWithoutMaps<null>> => {
      return testMethod(this, "assertValidWLSaleDates", params);
    },
    isSaleLive: async (
      params: Omit<
        TestContractParamsWithoutMaps<SaleFlatPriceAlphV2Types.Fields, never>,
        "testArgs"
      >
    ): Promise<TestContractResultWithoutMaps<boolean>> => {
      return testMethod(this, "isSaleLive", params);
    },
    isSaleFinished: async (
      params: Omit<
        TestContractParamsWithoutMaps<SaleFlatPriceAlphV2Types.Fields, never>,
        "testArgs"
      >
    ): Promise<TestContractResultWithoutMaps<boolean>> => {
      return testMethod(this, "isSaleFinished", params);
    },
    isSaleSuccess: async (
      params: Omit<
        TestContractParamsWithoutMaps<SaleFlatPriceAlphV2Types.Fields, never>,
        "testArgs"
      >
    ): Promise<TestContractResultWithoutMaps<boolean>> => {
      return testMethod(this, "isSaleSuccess", params);
    },
    isWhitelistSaleLive: async (
      params: Omit<
        TestContractParamsWithoutMaps<SaleFlatPriceAlphV2Types.Fields, never>,
        "testArgs"
      >
    ): Promise<TestContractResultWithoutMaps<boolean>> => {
      return testMethod(this, "isWhitelistSaleLive", params);
    },
    isWhitelistSale: async (
      params: Omit<
        TestContractParamsWithoutMaps<SaleFlatPriceAlphV2Types.Fields, never>,
        "testArgs"
      >
    ): Promise<TestContractResultWithoutMaps<boolean>> => {
      return testMethod(this, "isWhitelistSale", params);
    },
    isCallerSaleOwner: async (
      params: TestContractParamsWithoutMaps<
        SaleFlatPriceAlphV2Types.Fields,
        { caller: Address }
      >
    ): Promise<TestContractResultWithoutMaps<boolean>> => {
      return testMethod(this, "isCallerSaleOwner", params);
    },
    getSaleOwner: async (
      params: Omit<
        TestContractParamsWithoutMaps<SaleFlatPriceAlphV2Types.Fields, never>,
        "testArgs"
      >
    ): Promise<TestContractResultWithoutMaps<Address>> => {
      return testMethod(this, "getSaleOwner", params);
    },
    getSaleStart: async (
      params: Omit<
        TestContractParamsWithoutMaps<SaleFlatPriceAlphV2Types.Fields, never>,
        "testArgs"
      >
    ): Promise<TestContractResultWithoutMaps<bigint>> => {
      return testMethod(this, "getSaleStart", params);
    },
    getSaleEnd: async (
      params: Omit<
        TestContractParamsWithoutMaps<SaleFlatPriceAlphV2Types.Fields, never>,
        "testArgs"
      >
    ): Promise<TestContractResultWithoutMaps<bigint>> => {
      return testMethod(this, "getSaleEnd", params);
    },
    getMinRaise: async (
      params: Omit<
        TestContractParamsWithoutMaps<SaleFlatPriceAlphV2Types.Fields, never>,
        "testArgs"
      >
    ): Promise<TestContractResultWithoutMaps<bigint>> => {
      return testMethod(this, "getMinRaise", params);
    },
    getMaxRaise: async (
      params: Omit<
        TestContractParamsWithoutMaps<SaleFlatPriceAlphV2Types.Fields, never>,
        "testArgs"
      >
    ): Promise<TestContractResultWithoutMaps<bigint>> => {
      return testMethod(this, "getMaxRaise", params);
    },
    getSaleTokenId: async (
      params: Omit<
        TestContractParamsWithoutMaps<SaleFlatPriceAlphV2Types.Fields, never>,
        "testArgs"
      >
    ): Promise<TestContractResultWithoutMaps<HexString>> => {
      return testMethod(this, "getSaleTokenId", params);
    },
    getBidTokenId: async (
      params: Omit<
        TestContractParamsWithoutMaps<SaleFlatPriceAlphV2Types.Fields, never>,
        "testArgs"
      >
    ): Promise<TestContractResultWithoutMaps<HexString>> => {
      return testMethod(this, "getBidTokenId", params);
    },
    getWhitelistSaleStart: async (
      params: Omit<
        TestContractParamsWithoutMaps<SaleFlatPriceAlphV2Types.Fields, never>,
        "testArgs"
      >
    ): Promise<TestContractResultWithoutMaps<bigint>> => {
      return testMethod(this, "getWhitelistSaleStart", params);
    },
    getWhitelistSaleEnd: async (
      params: Omit<
        TestContractParamsWithoutMaps<SaleFlatPriceAlphV2Types.Fields, never>,
        "testArgs"
      >
    ): Promise<TestContractResultWithoutMaps<bigint>> => {
      return testMethod(this, "getWhitelistSaleEnd", params);
    },
    getTokensSold: async (
      params: Omit<
        TestContractParamsWithoutMaps<SaleFlatPriceAlphV2Types.Fields, never>,
        "testArgs"
      >
    ): Promise<TestContractResultWithoutMaps<bigint>> => {
      return testMethod(this, "getTokensSold", params);
    },
    getTotalRaised: async (
      params: Omit<
        TestContractParamsWithoutMaps<SaleFlatPriceAlphV2Types.Fields, never>,
        "testArgs"
      >
    ): Promise<TestContractResultWithoutMaps<bigint>> => {
      return testMethod(this, "getTotalRaised", params);
    },
    getMerkleRoot: async (
      params: Omit<
        TestContractParamsWithoutMaps<SaleFlatPriceAlphV2Types.Fields, never>,
        "testArgs"
      >
    ): Promise<TestContractResultWithoutMaps<HexString>> => {
      return testMethod(this, "getMerkleRoot", params);
    },
    updateRoot: async (
      params: TestContractParamsWithoutMaps<
        SaleFlatPriceAlphV2Types.Fields,
        { newMerkleRoot: HexString }
      >
    ): Promise<TestContractResultWithoutMaps<null>> => {
      return testMethod(this, "updateRoot", params);
    },
    verify: async (
      params: TestContractParamsWithoutMaps<
        SaleFlatPriceAlphV2Types.Fields,
        { proof: HexString; dataHash: HexString }
      >
    ): Promise<TestContractResultWithoutMaps<boolean>> => {
      return testMethod(this, "verify", params);
    },
    hashPair: async (
      params: TestContractParamsWithoutMaps<
        SaleFlatPriceAlphV2Types.Fields,
        { a: HexString; b: HexString }
      >
    ): Promise<TestContractResultWithoutMaps<HexString>> => {
      return testMethod(this, "hashPair", params);
    },
    hash: async (
      params: TestContractParamsWithoutMaps<
        SaleFlatPriceAlphV2Types.Fields,
        { dataToHash: HexString }
      >
    ): Promise<TestContractResultWithoutMaps<HexString>> => {
      return testMethod(this, "hash", params);
    },
  };
}

// Use this object to test and deploy the contract
export const SaleFlatPriceAlphV2 = new Factory(
  Contract.fromJson(
    SaleFlatPriceAlphV2ContractJson,
    "",
    "435b5baddda909c3cda88982ee8d90d3f86313a5dddb1c28f9ce72b655df82ad"
  )
);

// Use this class to interact with the blockchain
export class SaleFlatPriceAlphV2Instance extends ContractInstance {
  constructor(address: Address) {
    super(address);
  }

  async fetchState(): Promise<SaleFlatPriceAlphV2Types.State> {
    return fetchContractState(SaleFlatPriceAlphV2, this);
  }

  async getContractEventsCurrentCount(): Promise<number> {
    return getContractEventsCurrentCount(this.address);
  }

  subscribeBuyEvent(
    options: EventSubscribeOptions<SaleFlatPriceAlphV2Types.BuyEvent>,
    fromCount?: number
  ): EventSubscription {
    return subscribeContractEvent(
      SaleFlatPriceAlphV2.contract,
      this,
      options,
      "Buy",
      fromCount
    );
  }

  subscribeUpdateWhitelistBuyerMaxBidEvent(
    options: EventSubscribeOptions<SaleFlatPriceAlphV2Types.UpdateWhitelistBuyerMaxBidEvent>,
    fromCount?: number
  ): EventSubscription {
    return subscribeContractEvent(
      SaleFlatPriceAlphV2.contract,
      this,
      options,
      "UpdateWhitelistBuyerMaxBid",
      fromCount
    );
  }

  subscribeUpdatePublicSaleMaxBidEvent(
    options: EventSubscribeOptions<SaleFlatPriceAlphV2Types.UpdatePublicSaleMaxBidEvent>,
    fromCount?: number
  ): EventSubscription {
    return subscribeContractEvent(
      SaleFlatPriceAlphV2.contract,
      this,
      options,
      "UpdatePublicSaleMaxBid",
      fromCount
    );
  }

  subscribeUpdateUpfrontReleaseEvent(
    options: EventSubscribeOptions<SaleFlatPriceAlphV2Types.UpdateUpfrontReleaseEvent>,
    fromCount?: number
  ): EventSubscription {
    return subscribeContractEvent(
      SaleFlatPriceAlphV2.contract,
      this,
      options,
      "UpdateUpfrontRelease",
      fromCount
    );
  }

  subscribeUpdateVestingEndEvent(
    options: EventSubscribeOptions<SaleFlatPriceAlphV2Types.UpdateVestingEndEvent>,
    fromCount?: number
  ): EventSubscription {
    return subscribeContractEvent(
      SaleFlatPriceAlphV2.contract,
      this,
      options,
      "UpdateVestingEnd",
      fromCount
    );
  }

  subscribeUpdateCliffEndEvent(
    options: EventSubscribeOptions<SaleFlatPriceAlphV2Types.UpdateCliffEndEvent>,
    fromCount?: number
  ): EventSubscription {
    return subscribeContractEvent(
      SaleFlatPriceAlphV2.contract,
      this,
      options,
      "UpdateCliffEnd",
      fromCount
    );
  }

  subscribeAccountCreateEvent(
    options: EventSubscribeOptions<SaleFlatPriceAlphV2Types.AccountCreateEvent>,
    fromCount?: number
  ): EventSubscription {
    return subscribeContractEvent(
      SaleFlatPriceAlphV2.contract,
      this,
      options,
      "AccountCreate",
      fromCount
    );
  }

  subscribeAccountDestroyEvent(
    options: EventSubscribeOptions<SaleFlatPriceAlphV2Types.AccountDestroyEvent>,
    fromCount?: number
  ): EventSubscription {
    return subscribeContractEvent(
      SaleFlatPriceAlphV2.contract,
      this,
      options,
      "AccountDestroy",
      fromCount
    );
  }

  subscribeClaimBuyerEvent(
    options: EventSubscribeOptions<SaleFlatPriceAlphV2Types.ClaimBuyerEvent>,
    fromCount?: number
  ): EventSubscription {
    return subscribeContractEvent(
      SaleFlatPriceAlphV2.contract,
      this,
      options,
      "ClaimBuyer",
      fromCount
    );
  }

  subscribeClaimBuyerRefundEvent(
    options: EventSubscribeOptions<SaleFlatPriceAlphV2Types.ClaimBuyerRefundEvent>,
    fromCount?: number
  ): EventSubscription {
    return subscribeContractEvent(
      SaleFlatPriceAlphV2.contract,
      this,
      options,
      "ClaimBuyerRefund",
      fromCount
    );
  }

  subscribeClaimSellerEvent(
    options: EventSubscribeOptions<SaleFlatPriceAlphV2Types.ClaimSellerEvent>,
    fromCount?: number
  ): EventSubscription {
    return subscribeContractEvent(
      SaleFlatPriceAlphV2.contract,
      this,
      options,
      "ClaimSeller",
      fromCount
    );
  }

  subscribeClaimSellerRefundEvent(
    options: EventSubscribeOptions<SaleFlatPriceAlphV2Types.ClaimSellerRefundEvent>,
    fromCount?: number
  ): EventSubscription {
    return subscribeContractEvent(
      SaleFlatPriceAlphV2.contract,
      this,
      options,
      "ClaimSellerRefund",
      fromCount
    );
  }

  subscribeSaleDatesUpdateEvent(
    options: EventSubscribeOptions<SaleFlatPriceAlphV2Types.SaleDatesUpdateEvent>,
    fromCount?: number
  ): EventSubscription {
    return subscribeContractEvent(
      SaleFlatPriceAlphV2.contract,
      this,
      options,
      "SaleDatesUpdate",
      fromCount
    );
  }

  subscribeWhitelistSaleDatesUpdateEvent(
    options: EventSubscribeOptions<SaleFlatPriceAlphV2Types.WhitelistSaleDatesUpdateEvent>,
    fromCount?: number
  ): EventSubscription {
    return subscribeContractEvent(
      SaleFlatPriceAlphV2.contract,
      this,
      options,
      "WhitelistSaleDatesUpdate",
      fromCount
    );
  }

  subscribeUpdateRootEvent(
    options: EventSubscribeOptions<SaleFlatPriceAlphV2Types.UpdateRootEvent>,
    fromCount?: number
  ): EventSubscription {
    return subscribeContractEvent(
      SaleFlatPriceAlphV2.contract,
      this,
      options,
      "UpdateRoot",
      fromCount
    );
  }

  subscribeAllEvents(
    options: EventSubscribeOptions<
      | SaleFlatPriceAlphV2Types.BuyEvent
      | SaleFlatPriceAlphV2Types.UpdateWhitelistBuyerMaxBidEvent
      | SaleFlatPriceAlphV2Types.UpdatePublicSaleMaxBidEvent
      | SaleFlatPriceAlphV2Types.UpdateUpfrontReleaseEvent
      | SaleFlatPriceAlphV2Types.UpdateVestingEndEvent
      | SaleFlatPriceAlphV2Types.UpdateCliffEndEvent
      | SaleFlatPriceAlphV2Types.AccountCreateEvent
      | SaleFlatPriceAlphV2Types.AccountDestroyEvent
      | SaleFlatPriceAlphV2Types.ClaimBuyerEvent
      | SaleFlatPriceAlphV2Types.ClaimBuyerRefundEvent
      | SaleFlatPriceAlphV2Types.ClaimSellerEvent
      | SaleFlatPriceAlphV2Types.ClaimSellerRefundEvent
      | SaleFlatPriceAlphV2Types.SaleDatesUpdateEvent
      | SaleFlatPriceAlphV2Types.WhitelistSaleDatesUpdateEvent
      | SaleFlatPriceAlphV2Types.UpdateRootEvent
    >,
    fromCount?: number
  ): EventSubscription {
    return subscribeContractEvents(
      SaleFlatPriceAlphV2.contract,
      this,
      options,
      fromCount
    );
  }

  methods = {
    calculateClaimableAmount: async (
      params: SaleFlatPriceAlphV2Types.CallMethodParams<"calculateClaimableAmount">
    ): Promise<
      SaleFlatPriceAlphV2Types.CallMethodResult<"calculateClaimableAmount">
    > => {
      return callMethod(
        SaleFlatPriceAlphV2,
        this,
        "calculateClaimableAmount",
        params,
        getContractByCodeHash
      );
    },
    calculateSaleTokensReceivedPerBidTokens: async (
      params: SaleFlatPriceAlphV2Types.CallMethodParams<"calculateSaleTokensReceivedPerBidTokens">
    ): Promise<
      SaleFlatPriceAlphV2Types.CallMethodResult<"calculateSaleTokensReceivedPerBidTokens">
    > => {
      return callMethod(
        SaleFlatPriceAlphV2,
        this,
        "calculateSaleTokensReceivedPerBidTokens",
        params,
        getContractByCodeHash
      );
    },
    checkIsWhitelisted: async (
      params: SaleFlatPriceAlphV2Types.CallMethodParams<"checkIsWhitelisted">
    ): Promise<
      SaleFlatPriceAlphV2Types.CallMethodResult<"checkIsWhitelisted">
    > => {
      return callMethod(
        SaleFlatPriceAlphV2,
        this,
        "checkIsWhitelisted",
        params,
        getContractByCodeHash
      );
    },
    accountExists: async (
      params: SaleFlatPriceAlphV2Types.CallMethodParams<"accountExists">
    ): Promise<SaleFlatPriceAlphV2Types.CallMethodResult<"accountExists">> => {
      return callMethod(
        SaleFlatPriceAlphV2,
        this,
        "accountExists",
        params,
        getContractByCodeHash
      );
    },
    getSubContractId: async (
      params: SaleFlatPriceAlphV2Types.CallMethodParams<"getSubContractId">
    ): Promise<
      SaleFlatPriceAlphV2Types.CallMethodResult<"getSubContractId">
    > => {
      return callMethod(
        SaleFlatPriceAlphV2,
        this,
        "getSubContractId",
        params,
        getContractByCodeHash
      );
    },
    isSaleLive: async (
      params?: SaleFlatPriceAlphV2Types.CallMethodParams<"isSaleLive">
    ): Promise<SaleFlatPriceAlphV2Types.CallMethodResult<"isSaleLive">> => {
      return callMethod(
        SaleFlatPriceAlphV2,
        this,
        "isSaleLive",
        params === undefined ? {} : params,
        getContractByCodeHash
      );
    },
    isSaleFinished: async (
      params?: SaleFlatPriceAlphV2Types.CallMethodParams<"isSaleFinished">
    ): Promise<SaleFlatPriceAlphV2Types.CallMethodResult<"isSaleFinished">> => {
      return callMethod(
        SaleFlatPriceAlphV2,
        this,
        "isSaleFinished",
        params === undefined ? {} : params,
        getContractByCodeHash
      );
    },
    isSaleSuccess: async (
      params?: SaleFlatPriceAlphV2Types.CallMethodParams<"isSaleSuccess">
    ): Promise<SaleFlatPriceAlphV2Types.CallMethodResult<"isSaleSuccess">> => {
      return callMethod(
        SaleFlatPriceAlphV2,
        this,
        "isSaleSuccess",
        params === undefined ? {} : params,
        getContractByCodeHash
      );
    },
    isWhitelistSaleLive: async (
      params?: SaleFlatPriceAlphV2Types.CallMethodParams<"isWhitelistSaleLive">
    ): Promise<
      SaleFlatPriceAlphV2Types.CallMethodResult<"isWhitelistSaleLive">
    > => {
      return callMethod(
        SaleFlatPriceAlphV2,
        this,
        "isWhitelistSaleLive",
        params === undefined ? {} : params,
        getContractByCodeHash
      );
    },
    isWhitelistSale: async (
      params?: SaleFlatPriceAlphV2Types.CallMethodParams<"isWhitelistSale">
    ): Promise<
      SaleFlatPriceAlphV2Types.CallMethodResult<"isWhitelistSale">
    > => {
      return callMethod(
        SaleFlatPriceAlphV2,
        this,
        "isWhitelistSale",
        params === undefined ? {} : params,
        getContractByCodeHash
      );
    },
    isCallerSaleOwner: async (
      params: SaleFlatPriceAlphV2Types.CallMethodParams<"isCallerSaleOwner">
    ): Promise<
      SaleFlatPriceAlphV2Types.CallMethodResult<"isCallerSaleOwner">
    > => {
      return callMethod(
        SaleFlatPriceAlphV2,
        this,
        "isCallerSaleOwner",
        params,
        getContractByCodeHash
      );
    },
    getSaleOwner: async (
      params?: SaleFlatPriceAlphV2Types.CallMethodParams<"getSaleOwner">
    ): Promise<SaleFlatPriceAlphV2Types.CallMethodResult<"getSaleOwner">> => {
      return callMethod(
        SaleFlatPriceAlphV2,
        this,
        "getSaleOwner",
        params === undefined ? {} : params,
        getContractByCodeHash
      );
    },
    getSaleStart: async (
      params?: SaleFlatPriceAlphV2Types.CallMethodParams<"getSaleStart">
    ): Promise<SaleFlatPriceAlphV2Types.CallMethodResult<"getSaleStart">> => {
      return callMethod(
        SaleFlatPriceAlphV2,
        this,
        "getSaleStart",
        params === undefined ? {} : params,
        getContractByCodeHash
      );
    },
    getSaleEnd: async (
      params?: SaleFlatPriceAlphV2Types.CallMethodParams<"getSaleEnd">
    ): Promise<SaleFlatPriceAlphV2Types.CallMethodResult<"getSaleEnd">> => {
      return callMethod(
        SaleFlatPriceAlphV2,
        this,
        "getSaleEnd",
        params === undefined ? {} : params,
        getContractByCodeHash
      );
    },
    getMinRaise: async (
      params?: SaleFlatPriceAlphV2Types.CallMethodParams<"getMinRaise">
    ): Promise<SaleFlatPriceAlphV2Types.CallMethodResult<"getMinRaise">> => {
      return callMethod(
        SaleFlatPriceAlphV2,
        this,
        "getMinRaise",
        params === undefined ? {} : params,
        getContractByCodeHash
      );
    },
    getMaxRaise: async (
      params?: SaleFlatPriceAlphV2Types.CallMethodParams<"getMaxRaise">
    ): Promise<SaleFlatPriceAlphV2Types.CallMethodResult<"getMaxRaise">> => {
      return callMethod(
        SaleFlatPriceAlphV2,
        this,
        "getMaxRaise",
        params === undefined ? {} : params,
        getContractByCodeHash
      );
    },
    getSaleTokenId: async (
      params?: SaleFlatPriceAlphV2Types.CallMethodParams<"getSaleTokenId">
    ): Promise<SaleFlatPriceAlphV2Types.CallMethodResult<"getSaleTokenId">> => {
      return callMethod(
        SaleFlatPriceAlphV2,
        this,
        "getSaleTokenId",
        params === undefined ? {} : params,
        getContractByCodeHash
      );
    },
    getBidTokenId: async (
      params?: SaleFlatPriceAlphV2Types.CallMethodParams<"getBidTokenId">
    ): Promise<SaleFlatPriceAlphV2Types.CallMethodResult<"getBidTokenId">> => {
      return callMethod(
        SaleFlatPriceAlphV2,
        this,
        "getBidTokenId",
        params === undefined ? {} : params,
        getContractByCodeHash
      );
    },
    getWhitelistSaleStart: async (
      params?: SaleFlatPriceAlphV2Types.CallMethodParams<"getWhitelistSaleStart">
    ): Promise<
      SaleFlatPriceAlphV2Types.CallMethodResult<"getWhitelistSaleStart">
    > => {
      return callMethod(
        SaleFlatPriceAlphV2,
        this,
        "getWhitelistSaleStart",
        params === undefined ? {} : params,
        getContractByCodeHash
      );
    },
    getWhitelistSaleEnd: async (
      params?: SaleFlatPriceAlphV2Types.CallMethodParams<"getWhitelistSaleEnd">
    ): Promise<
      SaleFlatPriceAlphV2Types.CallMethodResult<"getWhitelistSaleEnd">
    > => {
      return callMethod(
        SaleFlatPriceAlphV2,
        this,
        "getWhitelistSaleEnd",
        params === undefined ? {} : params,
        getContractByCodeHash
      );
    },
    getTokensSold: async (
      params?: SaleFlatPriceAlphV2Types.CallMethodParams<"getTokensSold">
    ): Promise<SaleFlatPriceAlphV2Types.CallMethodResult<"getTokensSold">> => {
      return callMethod(
        SaleFlatPriceAlphV2,
        this,
        "getTokensSold",
        params === undefined ? {} : params,
        getContractByCodeHash
      );
    },
    getTotalRaised: async (
      params?: SaleFlatPriceAlphV2Types.CallMethodParams<"getTotalRaised">
    ): Promise<SaleFlatPriceAlphV2Types.CallMethodResult<"getTotalRaised">> => {
      return callMethod(
        SaleFlatPriceAlphV2,
        this,
        "getTotalRaised",
        params === undefined ? {} : params,
        getContractByCodeHash
      );
    },
    getMerkleRoot: async (
      params?: SaleFlatPriceAlphV2Types.CallMethodParams<"getMerkleRoot">
    ): Promise<SaleFlatPriceAlphV2Types.CallMethodResult<"getMerkleRoot">> => {
      return callMethod(
        SaleFlatPriceAlphV2,
        this,
        "getMerkleRoot",
        params === undefined ? {} : params,
        getContractByCodeHash
      );
    },
  };

  async multicall<Calls extends SaleFlatPriceAlphV2Types.MultiCallParams>(
    calls: Calls
  ): Promise<SaleFlatPriceAlphV2Types.MultiCallResults<Calls>> {
    return (await multicallMethods(
      SaleFlatPriceAlphV2,
      this,
      calls,
      getContractByCodeHash
    )) as SaleFlatPriceAlphV2Types.MultiCallResults<Calls>;
  }
}
